// Generated by CIRCT firtool-1.135.0

// Include register initializers in init blocks unless synthesis is set
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for register randomization.

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_
module CPU(
  input         clock,
  input         reset,
  input         io_halt,
  output        io_as,
  output        io_rw,
  output        io_uds,
  output        io_lds,
  input         io_dtack,
  input         io_vpa,
  input  [2:0]  io_ipl,
  output [2:0]  io_fc,
  output [22:0] io_addr,
  input  [15:0] io_din,
  output [15:0] io_dout
);

  wire _cpu_HALTn;
  wire _cpu_DTACKn;
  wire _cpu_BERRn = 1'h1;
  wire _cpu_VPAn;
  wire _cpu_BRn = 1'h1;
  wire _cpu_BGACKn = 1'h1;
  wire _cpu_IPL0n;
  wire _cpu_IPL1n;
  wire _cpu_IPL2n;
  wire _cpu_ASn;
  wire _cpu_UDSn;
  wire _cpu_LDSn;
  wire _cpu_FC0;
  wire _cpu_FC1;
  wire _cpu_FC2;
  reg  phi1_value;
  reg  phi2;
  always @(posedge clock) begin
    if (reset)
      phi1_value <= 1'h0;
    else
      phi1_value <= 1'(phi1_value - 1'h1);
    phi2 <= phi1_value;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        phi1_value = _RANDOM[/*Zero width*/ 1'b0][0];
        phi2 = _RANDOM[/*Zero width*/ 1'b0][1];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign _cpu_HALTn = ~io_halt;
  assign _cpu_DTACKn = ~io_dtack;
  assign _cpu_VPAn = ~io_vpa;
  assign _cpu_IPL0n = ~(io_ipl[0]);
  assign _cpu_IPL1n = ~(io_ipl[1]);
  assign _cpu_IPL2n = ~(io_ipl[2]);
  fx68k cpu (
    .clk      (clock),
    .enPhi1   (phi1_value),
    .enPhi2   (phi2),
    .extReset (reset),
    .pwrUp    (reset),
    .HALTn    (_cpu_HALTn),
    .ASn      (_cpu_ASn),
    .eRWn     (io_rw),
    .UDSn     (_cpu_UDSn),
    .LDSn     (_cpu_LDSn),
    .DTACKn   (_cpu_DTACKn),
    .BERRn    (_cpu_BERRn),
    .E        (/* unused */),
    .VPAn     (_cpu_VPAn),
    .VMAn     (/* unused */),
    .BRn      (_cpu_BRn),
    .BGn      (/* unused */),
    .BGACKn   (_cpu_BGACKn),
    .IPL0n    (_cpu_IPL0n),
    .IPL1n    (_cpu_IPL1n),
    .IPL2n    (_cpu_IPL2n),
    .FC0      (_cpu_FC0),
    .FC1      (_cpu_FC1),
    .FC2      (_cpu_FC2),
    .eab      (io_addr),
    .iEdb     (io_din),
    .oEdb     (io_dout)
  );
  assign io_as = ~_cpu_ASn;
  assign io_uds = ~_cpu_UDSn;
  assign io_lds = ~_cpu_LDSn;
  assign io_fc = {_cpu_FC2, _cpu_FC1, _cpu_FC0};
endmodule


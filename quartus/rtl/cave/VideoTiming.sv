// Generated by CIRCT firtool-1.135.0

// Include register initializers in init blocks unless synthesis is set
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for register randomization.

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_
module VideoTiming(
  input        clock,
  input        reset,
  input  [8:0] io_display_x,
  input  [8:0] io_display_y,
  input  [8:0] io_frontPorch_x,
  input  [8:0] io_frontPorch_y,
  input  [8:0] io_retrace_x,
  input  [8:0] io_retrace_y,
  input  [3:0] io_offset_x,
  input  [3:0] io_offset_y,
  output       io_timing_clockEnable,
  output       io_timing_displayEnable,
  output [8:0] io_timing_pos_x,
  output [8:0] io_timing_pos_y,
  output       io_timing_hSync,
  output       io_timing_vSync,
  output       io_timing_hBlank,
  output       io_timing_vBlank
);

  reg  [1:0] clockDivWrap_value;
  reg  [8:0] x;
  wire [9:0] _GEN = {1'h0, x};
  reg  [8:0] y;
  wire [9:0] _GEN_0 = {1'h0, y};
  wire [9:0] _hEndDisplay_T = 10'({{6{io_offset_x[3]}}, io_offset_x} + 10'h1C0);
  wire [9:0] _GEN_1 = {1'h0, io_frontPorch_x};
  wire [9:0] _GEN_2 = {1'h0, io_retrace_x};
  wire [9:0] _hBeginDisplay_T_8 =
    10'(10'(10'(_hEndDisplay_T - {1'h0, io_display_x}) - _GEN_1) - _GEN_2);
  wire [9:0] _vEndDisplay_T = 10'({{6{io_offset_y[3]}}, io_offset_y} + 10'h110);
  wire [9:0] _GEN_3 = {1'h0, io_frontPorch_y};
  wire [9:0] _GEN_4 = {1'h0, io_retrace_y};
  wire [9:0] _vBeginDisplay_T_8 =
    10'(10'(10'(_vEndDisplay_T - {1'h0, io_display_y}) - _GEN_3) - _GEN_4);
  wire       hBlank =
    _GEN < _hBeginDisplay_T_8 | _GEN >= 10'(10'(_hEndDisplay_T - _GEN_1) - _GEN_2);
  wire       vBlank =
    _GEN_0 < _vBeginDisplay_T_8 | _GEN_0 >= 10'(10'(_vEndDisplay_T - _GEN_3) - _GEN_4);
  wire       wrap_wrap = x == 9'h1BF;
  always @(posedge clock) begin
    if (reset) begin
      clockDivWrap_value <= 2'h0;
      x <= 9'h0;
      y <= 9'h0;
    end
    else begin
      clockDivWrap_value <= 2'(clockDivWrap_value + 2'h1);
      if (&clockDivWrap_value)
        x <= wrap_wrap ? 9'h0 : 9'(x + 9'h1);
      if ((&clockDivWrap_value) & wrap_wrap)
        y <= y == 9'h10F ? 9'h0 : 9'(y + 9'h1);
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        clockDivWrap_value = _RANDOM[/*Zero width*/ 1'b0][1:0];
        x = _RANDOM[/*Zero width*/ 1'b0][10:2];
        y = _RANDOM[/*Zero width*/ 1'b0][19:11];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_timing_clockEnable = &clockDivWrap_value;
  assign io_timing_displayEnable = ~(hBlank | vBlank);
  assign io_timing_pos_x = 9'(x - _hBeginDisplay_T_8[8:0]);
  assign io_timing_pos_y = 9'(y - _vBeginDisplay_T_8[8:0]);
  assign io_timing_hSync = x >= 9'(9'h1C0 - io_retrace_x) & x[8:6] != 3'h7;
  assign io_timing_vSync = y >= 9'(9'h110 - io_retrace_y) & y < 9'h110;
  assign io_timing_hBlank = hBlank;
  assign io_timing_vBlank = vBlank;
endmodule

